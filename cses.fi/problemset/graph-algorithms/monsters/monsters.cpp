// a10n - Wed Feb  2 12:30:19 2022
// Monsters (https://cses.fi/problemset/task/1194)
// Generated by cptk

#include <bits/stdc++.h>
using namespace std;

#define int long long
#define fori(n, i) for (int i = 0; i < n; i++)
#define x first
#define y second

typedef vector<int> vi;
typedef pair<int, int> ii;
typedef vector<ii> vii;

map<char, ii> moves = {
    {'U', {-1, 0}},
    {'D', {1, 0}},
    {'L', {0, -1}},
    {'R', {0, 1}},
};

const int maxn = 1005;
char b[maxn][maxn];
char f[maxn][maxn];
int n, m;

bool blocks(char a, char b) {
    // returns true if a blocks b
    if (a == b) return true;
    switch (a) {
        case '#':
            return true;
        case 'M':
            return b == 'A';
    }
    return false;
}

vii iterateBfs(queue<pair<ii, int>>& q, char c, int d) {
    // iterates until the stack contains elements of depth >= d
    // return true if reached the edge.

    vii res;

    while (!q.empty() && q.front().y < d) {
        int i = q.front().x.x, j = q.front().x.y, dd = q.front().y;
        q.pop();

        if (i == 0 || i == n - 1 || j == 0 || j == m - 1) res.push_back({i, j});
        for (auto mv : moves) {
            int ni = i + mv.y.x, nj = j + mv.y.y;

            if (ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
            if (blocks(b[ni][nj], c)) continue;

            b[ni][nj] = c;
            if (c == 'A') f[ni][nj] = mv.x;
            q.push({{ni, nj}, dd + 1});
        }
    }

    return res;
}

void printPath(int i, int j) {
    stack<char> stk;
    while (f[i][j] != 1) {
        char ltr = f[i][j];
        stk.push(ltr);
        i -= moves[ltr].x, j -= moves[ltr].y;
    }

    cout << stk.size() << endl;

    while (!stk.empty()) {
        cout << stk.top();
        stk.pop();
    }

    cout << endl;
}

signed main() {
    cin.tie(NULL)->sync_with_stdio(false);
    cin >> n >> m;
    queue<pair<ii, int>> monster, player;

    fori(n, i) fori(m, j) {
        cin >> b[i][j];
        switch (b[i][j]) {
            case 'M':
                monster.push({{i, j}, 0});
                break;
            case 'A':
                f[i][j] = 1;
                player.push({{i, j}, 0});
                break;
        }
    }

    int d = 0;
    while (!player.empty()) {
        iterateBfs(monster, 'M', ++d);
        vii edges = iterateBfs(player, 'A', d);
        if (edges.size() > 0) {
            cout << "YES" << endl;
            printPath(edges[0].x, edges[0].y);
            return 0;
        }
    }

    cout << "NO" << endl;
}
