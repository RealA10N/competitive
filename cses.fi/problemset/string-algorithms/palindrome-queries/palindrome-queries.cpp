// a10n - Wed Apr 20 17:37:08 2022
// Palindrome Queries (https://cses.fi/problemset/task/2420)
// Generated by cptk

#include <bits/stdc++.h>
using namespace std;

#define int long long
#define all(x) (x).begin(), (x).end()
#define fori(n, i) for (int i = 0; i < n; i++)
#define sz(x) (int)(x.size())
#define blksz(i) (i & -i)
#define nxtblk(i) (i + blksz(i))
#define prvblk(i) (i - blksz(i))
#define ctoi(x) (x - 'a' + 1)

typedef vector<int> vi;
typedef pair<int, int> ii;

const int maxn = 2e5;
const int MOD = 1e9 - 63;
const int P = 31;
int p[maxn];

int mod(int a) { return a %= MOD, (a < 0 ? MOD : 0) + a; }

void precompute() {
    p[0] = 1;
    for (int i = 1; i < maxn; i++) p[i] = mod(p[i - 1] * P);
}

int powm(int a, int b) {
    if (!b) return 1;
    int c = powm(a, b / 2);
    c = mod(c * c);
    if (b & 1) c = mod(c * a);
    return c;
}

int divm(int a, int b) { return mod(a * powm(b, MOD - 2)); }

typedef struct fenwick {
    int n;
    vi fw;

    fenwick(const vi& s) : n(sz(s) + 1), fw(n, 0) {
        for (int i = 1; i <= n; i++) add(i, s[i - 1]);
    }

    void add(int i, int v) {
        v = mod(v * p[i - 1]);
        while (i < n) fw[i] = mod(fw[i] + v), i = nxtblk(i);
    }

    int get(int i) {
        int s = 0;
        while (i > 0) s = mod(s + fw[i]), i = prvblk(i);
        return s;
    }

    int hash(int a, int b) {
        int h = mod(get(b) - get(a - 1));
        h = divm(h, p[a - 1]);
        return h;
    }

} fenwick;

signed main() {
    cin.tie(NULL)->sync_with_stdio(false);
    precompute();

    int n, q;
    cin >> n >> q;

    string string;
    cin >> string;
    vi s(n), sr(n);
    fori(n, i) s[i] = sr[n - 1 - i] = ctoi(string[i]);
    fenwick left(s), right(sr);

    while (q--) {
        int t;
        cin >> t;
        if (t == 1) {
            int k;
            char x;
            cin >> k >> x;
            int d = ctoi(x) - s[k - 1];
            s[k - 1] = ctoi(x);
            left.add(k, d), right.add(n - k + 1, d);
        } else {
            int a, b;
            cin >> a >> b;
            int le = left.hash(a, b);
            int ri = right.hash(n - b + 1, n - a + 1);
            cout << (le == ri ? "YES" : "NO") << endl;
        }
    }
}
